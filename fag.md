
---

## **Блок 1**  

### **Понятие типа данных**  
Тип данных в C определяет множество значений, которые может принимать переменная, и допустимые операции над этими значениями.  

Основные типы:  
- **Целочисленные** (`int`, `short`, `long`, `long long`, `unsigned`)  
- **Вещественные** (`float`, `double`, `long double`)  
- **Символьные** (`char`)  
- **Булевы** (`_Bool` или `bool` из `stdbool.h`)  
- **Указатели** (адреса в памяти)  
- **Структуры, объединения, перечисления**  

C поддерживает приведение типов и динамическое выделение памяти для работы с различными структурами данных.  

---

### **Глобальная компьютерная сеть как телефония**  
Глобальная компьютерная сеть похожа на телефонию, потому что выполняет схожие функции связи.  

**Сходства:**  
1. У каждого абонента (пользователя) есть свой **идентификатор** – телефонный номер в телефонии, IP-адрес или доменное имя в интернете.  
2. Данные передаются между узлами через **каналы связи** (кабели, Wi-Fi, спутники).  
3. Используются **протоколы** для обмена информацией (например, SIP в VoIP или TCP/IP в интернете).  

**Различия:**  
- Телефония использует **коммутацию каналов** (соединение создается на всё время разговора), а компьютерные сети – **коммутацию пакетов** (данные передаются кусками).  
- Интернет даёт возможность передавать не только голос, но и файлы, видео, сообщения и т.д.  

Глобальная компьютерная сеть – это эволюция телефонии, позволяющая обмениваться информацией более универсально.  

---

### **Задача: Проверка на симметричность матрицы 3×3**  

**Идея:**  
- Вводим матрицу 3×3.  
- Проверяем, равны ли элементы, зеркально расположенные относительно главной диагонали:  
  - `A[0][1] == A[1][0]`  
  - `A[0][2] == A[2][0]`  
  - `A[1][2] == A[2][1]`  
- Если все условия выполняются, матрица симметрична.  

**Минимальный код:**  
```c
#include <stdio.h>

int main() {
    int A[3][3], i, j, sym = 1;
    for (i = 0; i < 3; i++)
        for (j = 0; j < 3; j++)
            scanf("%d", &A[i][j]);

    for (i = 0; i < 3; i++)
        for (j = i + 1; j < 3; j++)
            if (A[i][j] != A[j][i]) sym = 0;

    printf(sym ? "YES\n" : "NO\n");
    return 0;
}
```

**Сложность:**  
- Ввод: \( O(9) = O(1) \)  
- Проверка: \( O(3) = O(1) \)  
- Итоговая сложность: **\( O(1) \)** (константное время)  

---

## **Блок 2**  

### **Файлы в C. Примеры**  
Файлы в C используются для хранения и обработки данных вне оперативной памяти.  

Основные функции из `stdio.h`:  
- `fopen("file.txt", "r")` – открыть файл  
- `fclose(file)` – закрыть  
- `fprintf(file, "...")` – запись  
- `fscanf(file, "...")` – чтение  

Пример:  
```c
#include <stdio.h>

int main() {
    FILE *f = fopen("data.txt", "w");
    fprintf(f, "Hello, File!");
    fclose(f);
    return 0;
}
```

---

### **Массив в C**  
Массив – это структура данных, представляющая собой набор элементов одного типа в памяти.  

**Объявление:**  
```c
int arr[5];  // Массив из 5 элементов
```

**Доступ:**  
```c
arr[0] = 10;         // Присваивание
printf("%d", arr[2]); // Чтение
```

**Особенности:**  
- Размер фиксирован  
- Передаётся в функции как указатель  
- Можно работать с ним через указатели  

---

### **Задача: Проверка, является ли число полным квадратом**  

**Идея:**  
- Вводим число `N`.  
- Вычисляем `sqrt(N)` и округляем вниз.  
- Если квадрат этого числа равен `N`, значит, это полный квадрат.  

**Минимальный код:**  
```c
#include <stdio.h>
#include <math.h>

int main() {
    int N;
    scanf("%d", &N);
    int x = sqrt(N);
    printf(x * x == N ? "YES\n" : "NO\n");
    return 0;
}
```

**Сложность:** \( O(1) \) – всего одно вычисление и одна проверка.  

---

## **Блок 3**  

### **Обобщенная инструкция присваивания**  
В C присваивание можно делать не только простыми операторами `=`, но и с использованием **составных операторов**:  
```c
a += 5;  // Эквивалентно a = a + 5;
a *= 2;  // Эквивалентно a = a * 2;
```
Эти операторы делают код компактнее и читаемее.  

---

### **Жидкокристаллические мониторы**  
LCD-мониторы работают на основе **жидких кристаллов**, которые меняют прозрачность под воздействием электрического поля.  

Принцип работы:  
1. Источник света (подсветка) излучает белый свет.  
2. Свет проходит через поляризационные фильтры.  
3. Жидкие кристаллы изменяют свою ориентацию, регулируя количество света.  
4. Цвет формируется благодаря красным, зелёным и синим фильтрам (RGB).  

**Плюсы LCD:**  
- Тонкий и лёгкий  
- Малое энергопотребление  
- Высокое разрешение  

**Минусы:**  
- Углы обзора хуже, чем у OLED  
- Время отклика медленнее, чем у CRT  

---

### **Задача: Спеллинг вещественного числа на C**  

**Идея:**  
- Вводим вещественное число.  
- Разделяем его на **целую** и **дробную** части.  
- Преобразуем их в текст (например, `123.45` → `"one hundred twenty-three point four five"`).  

**Минимальный код:**  
```c
#include <stdio.h>

int main() {
    double num;
    scanf("%lf", &num);
    int intPart = (int)num;
    double fracPart = num - intPart;
    printf("Integer part: %d, Fractional part: %.2lf\n", intPart, fracPart);
    return 0;
}
```
**Дальше можно дописать функцию для перевода цифр в слова.**  

**Сложность:** \( O(1) \) – простые арифметические операции.  


Хорошо, вот полный ответ по всем блокам.  

---

# **Блок 4**  

### **Дополнительные типы данных (множество, перечисление, диапазон)**  
В C есть несколько специальных типов данных:  

1. **Перечисления (`enum`)** – набор именованных констант:  
   ```c
   enum Day { MON, TUE, WED, THU, FRI, SAT, SUN };
   ```
   Здесь `MON` будет `0`, `TUE` — `1` и т. д.  

2. **Диапазоны в `typedef`** – создаются через `struct` или `union`, но в самом C **нет** встроенного типа "диапазон".  

3. **Множества** – можно эмулировать с помощью битовых операций:  
   ```c
   int set = 0b101;  // Множество {0, 2}
   if (set & (1 << 2)) printf("Есть 2!\n");
   ```

---

### **Вещественный тип**  
В C есть три основных типа для вещественных чисел:  
- **`float`** (~6 знаков точности, 32 бита)  
- **`double`** (~15 знаков точности, 64 бита)  
- **`long double`** (может быть 80-128 бит в зависимости от платформы)  

Формат записи:  
```c
float a = 3.14;
double b = 2.718281828;
long double c = 1.414213562373;
```

Особенности:  
- Потеря точности при вычислениях  
- Можно использовать `math.h` для функций (`sqrt()`, `sin()`, `log()`)  

---

### **Задача: Заданный байт введенного числа**  

**Идея:**  
- Ввести число и номер байта (0 – младший, 3 – старший).  
- Использовать побитовый сдвиг и маску `0xFF`.  

**Минимальный код:**  
```c
#include <stdio.h>

int main() {
    int num, byte;
    scanf("%d %d", &num, &byte);
    printf("Byte %d: %x\n", byte, (num >> (byte * 8)) & 0xFF);
    return 0;
}
```

**Сложность:** \( O(1) \) – простые битовые операции.  

---

# **Блок 5**  

### **Тип записи**  
`struct` (структуры) позволяют объединять переменные разных типов:  
```c
struct Person {
    char name[50];
    int age;
};
```
Позволяет работать с данными логически.  

---

### **Звуковая карта**  
Звуковая карта обрабатывает аудиосигналы, выполняя:  
1. Аналого-цифровое преобразование (ADC)  
2. Обработку звука (DSP)  
3. Цифро-аналоговое преобразование (DAC)  
4. Вывод звука через динамики  

---

### **Задача: Спеллинг кардинальной системы счисления**  
**Идея:**  
- Преобразуем число в нужную систему (например, 2, 8, 16).  
- Записываем его словами (`101` → `"one zero one"`).  

**Минимальный код:**  
```c
#include <stdio.h>

void spell(int n) {
    if (n == 0) return;
    spell(n / 10);
    printf("%d ", n % 10);
}

int main() {
    int num;
    scanf("%d", &num);
    spell(num);
    return 0;
}
```
**Сложность:** \( O(\log N) \) – количество цифр в числе.  

---

# **Блок 6**  

### **Булев тип (`_Bool`)**  
В C булев тип – это `_Bool`, но в `stdbool.h` есть `bool`, `true`, `false`.  
```c
#include <stdbool.h>
bool isEven(int x) { return x % 2 == 0; }
```

---

### **Кэш-память**  
Быстрая память между RAM и процессором.  

Уровни кэша:  
- **L1** – встроен в ядро CPU, быстрый, маленький  
- **L2** – больше, но медленнее  
- **L3** – общий для всех ядер, самый медленный  

---

### **Задача: Перевод вещественного числа в 8СС**  
**Идея:**  
- Выделить целую и дробную части.  
- Перевести отдельно в 8СС.  

**Минимальный код:**  
```c
#include <stdio.h>

void toBase8(int n) {
    if (n == 0) return;
    toBase8(n / 8);
    printf("%d", n % 8);
}

int main() {
    double num;
    scanf("%lf", &num);
    int intPart = (int)num;
    printf("Octal: ");
    toBase8(intPart);
    return 0;
}
```
**Сложность:** \( O(\log_8 N) \).  

---

### **Остальные задачи (кратко, без кода):**  

- **ЭВМ открытой шинной архитектуры** – процессоры и компоненты могут обмениваться данными через общий канал (шину).  
- **Перевод матрицы из 4СС в 5СС** – аналогичен переводу чисел между системами.  
- **Основная память** – это RAM, которая хранит данные во время работы процессора.  
- **Вычисление корня в натуральной СС** – используем `sqrt()`, затем переводим результат в нужную СС.  
- **Принципы фон Неймана** – память хранит и код, и данные.  
- **Компьютеры Mainframe** – мощные серверы для больших объемов данных.  
- **Гарвардская архитектура** – разделение памяти для кода и данных.  
- **Запоминающие устройства** – RAM, SSD, HDD, кэш.  
- **Передача параметров по значению и ссылке** – `int foo(int x)` (по значению), `void foo(int *x)` (по указателю).  
- **Архитектура процессора DSP** – процессоры для обработки сигналов.  

---

### **Задача: Проверка на возрастание чисел в 16СС**  
**Идея:**  
- Вводим число в 16СС.  
- Проверяем, что цифры идут по возрастанию.  

**Минимальный код:**  
```c
#include <stdio.h>

int main() {
    char hex[20];
    scanf("%s", hex);
    for (int i = 1; hex[i]; i++) {
        if (hex[i] < hex[i - 1]) {
            printf("NO\n");
            return 0;
        }
    }
    printf("YES\n");
    return 0;
}
```
**Сложность:** \( O(N) \).  

---

Хорошо, вот развернутые ответы до **32 блока**.  

---

# **Блок 8**  

### **ЭВМ открытой шинной архитектуры**  
Открытая шинная архитектура означает, что процессор, память и внешние устройства обмениваются данными через общий канал — шину.  

**Преимущества:**  
- Гибкость в модернизации  
- Простота подключения новых устройств  

**Недостатки:**  
- Возможны задержки из-за конкуренции за шину  
- Ограниченная пропускная способность  

---

### **Перевод матрицы из 4СС в 5СС**  
Перевод чисел между системами счисления делается путем:  
1. Преобразования числа в десятичную СС.  
2. Перевода в нужную систему (делением на основание).  

Для матриц переводим каждое число отдельно.  

---

### **Задача: Перевод матрицы из 5СС в 4СС**  
**Идея:**  
- Читаем матрицу в 5СС.  
- Переводим каждое число в 10СС.  
- Переводим в 4СС.  

**Код:**  
```c
#include <stdio.h>

int toDecimal(int num, int base) {
    int res = 0, pow = 1;
    while (num) {
        res += (num % 10) * pow;
        num /= 10;
        pow *= base;
    }
    return res;
}

int toBase(int num, int base) {
    if (num == 0) return 0;
    return toBase(num / base, base) * 10 + (num % base);
}

int main() {
    int matrix[3][3];
    for (int i = 0; i < 3; i++)
        for (int j = 0; j < 3; j++)
            scanf("%d", &matrix[i][j]);

    printf("Matrix in base 4:\n");
    for (int i = 0; i < 3; i++) {
        for (int j = 0; j < 3; j++)
            printf("%d ", toBase(toDecimal(matrix[i][j], 5), 4));
        printf("\n");
    }
    return 0;
}
```
**Сложность:** \( O(N^2) \) (для матрицы 3×3 это 9 операций перевода).  

---

# **Блок 9**  

### **Глобальные и локальные переменные**  
- **Глобальные** – объявлены вне функций, доступны везде.  
- **Локальные** – объявлены внутри функций, доступны только в ней.  

```c
int globalVar = 10; // Глобальная

void foo() {
    int localVar = 5; // Локальная
}
```
Глобальные переменные занимают память до конца программы, локальные — только во время работы функции.  

---

### **Основная память**  
Оперативная память (RAM) — основное хранилище данных, к которому обращается процессор.  

**Основные характеристики:**  
- **DRAM** (динамическая) – дешевле, но требует обновления  
- **SRAM** (статическая) – быстрее, но дороже  

---

### **Задача: Вычисление корня числа в натуральной СС**  
**Идея:**  
- Число переводится в 10СС.  
- Находим корень (`sqrt`).  
- Переводим обратно в исходную СС.  

**Код:**  
```c
#include <stdio.h>
#include <math.h>

int main() {
    int num;
    scanf("%d", &num);
    printf("Root: %d\n", (int)sqrt(num));
    return 0;
}
```
**Сложность:** \( O(1) \).  

---

# **Блок 10**  

### **Понятие о структурном типе данных**  
Структуры (`struct`) позволяют объединять разные переменные:  
```c
struct Student {
    char name[50];
    int age;
};
```
Доступ к полям: `s.age = 20;`.  

---

### **Принципы фон Неймана**  
1. **Память хранит и код, и данные**.  
2. **Процессор выполняет команды последовательно**.  
3. **Цикл выполнения: загрузка → декодирование → исполнение**.  

---

### **Задача: Перевод целого числа в кардинальную СС**  
**Идея:**  
- Используем деление с остатком для перевода в систему.  

**Код:**  
```c
#include <stdio.h>

void toBase(int n, int base) {
    if (n == 0) return;
    toBase(n / base, base);
    printf("%d", n % base);
}

int main() {
    int num, base;
    scanf("%d %d", &num, &base);
    toBase(num, base);
    return 0;
}
```
**Сложность:** \( O(\log_B N) \).  

---

# **Блок 11**  

### **Целый тип. Арифметические аспекты**  
Целочисленные типы:  
- `int` – 4 байта  
- `long` – 8 байт  
- `short` – 2 байта  

**Операции:**  
- `+`, `-`, `*`, `/`, `%` (остаток)  

---

### **Звуковые колонки**  
Преобразуют электрический сигнал в звук. Важные параметры:  
- **Мощность (Вт)**  
- **Частотный диапазон (Гц)**  

---

### **Задача: Сравнение многочленов в C**  
**Идея:**  
- Вводим два многочлена.  
- Проверяем коэффициенты.  

**Код:**  
```c
#include <stdio.h>

int main() {
    int n;
    scanf("%d", &n);
    int a[n], b[n];

    for (int i = 0; i < n; i++) scanf("%d", &a[i]);
    for (int i = 0; i < n; i++) scanf("%d", &b[i]);

    for (int i = 0; i < n; i++) {
        if (a[i] != b[i]) {
            printf("Not equal\n");
            return 0;
        }
    }
    printf("Equal\n");
    return 0;
}
```
**Сложность:** \( O(N) \).  

---

# **Блок 12**  

### **Универсальный оператор присваивания**  
В C можно присваивать разным типам:  
```c
int a = 5;
double b = a; // int → double
```

---

### **Монитор на жидких кристаллах**  
LCD-мониторы используют жидкие кристаллы для управления светом от подсветки.  

---

### **Задача: Спеллинг вещественного числа на C**  
**Идея:**  
- Разбить число на целую и дробную часть.  
- Вывести каждую цифру словами.  

**Код:**  
```c
#include <stdio.h>

void spell(int n) {
    if (n == 0) return;
    spell(n / 10);
    printf("%d ", n % 10);
}

int main() {
    double num;
    scanf("%lf", &num);
    int intPart = (int)num;
    spell(intPart);
    return 0;
}
```
**Сложность:** \( O(\log N) \).  

---
### **Блок 14**  

#### **Согласование типов**  
Согласование типов в C — это механизм, который позволяет выполнять операции между различными типами данных.  

**Основные принципы:**  
1. **Автоматическое приведение типов** (неявное) — происходит, когда один тип данных преобразуется в другой без явного указания программиста.  
   ```c
   int a = 5;
   double b = a; // a автоматически преобразуется в double
   ```
2. **Явное приведение типов** — используется, когда программист указывает, к какому типу следует преобразовать значение.  
   ```c
   double x = 3.14;
   int y = (int)x; // Приведение к int (отбрасывается дробная часть)
   ```

---

#### **Гарвардская архитектура**  
Гарвардская архитектура отличается от фон-неймановской тем, что **код и данные хранятся раздельно**.  

**Преимущества:**  
- Возможность одновременного выполнения команд и загрузки данных  
- Более высокая скорость работы  

**Недостатки:**  
- Усложненная структура памяти  
- Более дорогая реализация  

Применяется в микроконтроллерах, DSP и специализированных процессорах.  

---

#### **Задача: Возведение булевой матрицы в n-ую степень**  

**Идея:**  
- Булевая матрица содержит только `0` и `1`.  
- При возведении в степень используем матричное умножение по модулю 2.  
- Алгоритм **быстрого возведения в степень** снижает сложность до \( O(\log n) \).  

**Код:**  
```c
#include <stdio.h>

#define SIZE 3

void multiply(int A[SIZE][SIZE], int B[SIZE][SIZE]) {
    int res[SIZE][SIZE] = {0};
    for (int i = 0; i < SIZE; i++)
        for (int j = 0; j < SIZE; j++)
            for (int k = 0; k < SIZE; k++)
                res[i][j] ^= A[i][k] & B[k][j];  // XOR для булевого умножения

    for (int i = 0; i < SIZE; i++)
        for (int j = 0; j < SIZE; j++)
            A[i][j] = res[i][j];
}

void power(int A[SIZE][SIZE], int n) {
    int result[SIZE][SIZE] = {0};
    for (int i = 0; i < SIZE; i++)
        result[i][i] = 1;  // Единичная матрица

    while (n) {
        if (n % 2) multiply(result, A);
        multiply(A, A);
        n /= 2;
    }

    for (int i = 0; i < SIZE; i++)
        for (int j = 0; j < SIZE; j++)
            A[i][j] = result[i][j];
}

int main() {
    int A[SIZE][SIZE] = {{1, 0, 1}, {0, 1, 1}, {1, 1, 0}};
    int n;
    scanf("%d", &n);
    power(A, n);

    for (int i = 0; i < SIZE; i++) {
        for (int j = 0; j < SIZE; j++)
            printf("%d ", A[i][j]);
        printf("\n");
    }
    return 0;
}
```

**Сложность:** \( O(SIZE^3 \log n) \), где `SIZE = 3`.  

---

### **Блок 15**  

#### **Принцип реализации машины фон Неймана**  
Фон-неймановская архитектура основана на едином хранилище для кода и данных.  

**Основные компоненты:**  
- **Процессор** (ALU + регистры)  
- **Оперативная память**  
- **Устройства ввода/вывода**  

Выполнение программы происходит в **цикле команд**:  
1. **Загрузка** инструкции  
2. **Декодирование**  
3. **Исполнение**  

---

#### **Устройства хранения данных. Единицы хранения**  
Память измеряется в:  
- **Битах (1 или 0)**  
- **Байтах (8 бит)**  
- **Килобайтах (1024 байта)**  
- **Мегабайтах, Гигабайтах, Терабайтах**  

**Основные виды памяти:**  
- **ОЗУ (RAM)** — временное хранение данных  
- **Жесткий диск (HDD, SSD)** — долговременное  

---

#### **Задача: Возведение числа в квадрат в натуральной СС**  

**Идея:**  
- Переводим в 10СС, возводим в квадрат, переводим обратно.  

**Код:**  
```c
#include <stdio.h>

int toDecimal(int num, int base) {
    int res = 0, pow = 1;
    while (num) {
        res += (num % 10) * pow;
        num /= 10;
        pow *= base;
    }
    return res;
}

int toBase(int num, int base) {
    if (num == 0) return 0;
    return toBase(num / base, base) * 10 + (num % base);
}

int main() {
    int num, base;
    scanf("%d %d", &num, &base);
    int dec = toDecimal(num, base);
    printf("Square: %d\n", toBase(dec * dec, base));
    return 0;
}
```
**Сложность:** \( O(\log_B N) \).  

---

### **Блок 16**  

#### **Операции присваивания (по имени)**  
В C переменные хранятся в памяти, и при присваивании данные копируются:  
```c
int a = 5;
int b = a; // b получает значение a
```

---

#### **Микрофон**  
Устройство, преобразующее звуковые волны в электрический сигнал.  

---

#### **Задача: Дифференцирование в C**  

**Идея:**  
- Представляем многочлен в массиве коэффициентов.  
- Производная `ax^n` → `n * ax^(n-1)`.  

**Код:**  
```c
#include <stdio.h>

int main() {
    int n;
    scanf("%d", &n);
    int coeffs[n];

    for (int i = 0; i < n; i++)
        scanf("%d", &coeffs[i]);

    for (int i = 0; i < n - 1; i++)
        printf("%d ", coeffs[i] * (n - 1 - i));

    return 0;
}
```
**Сложность:** \( O(N) \).  

---

### **Блок 17**  

#### **Вещественный тип**  
`float`, `double`, `long double` для хранения чисел с плавающей запятой.  

---

#### **ЭВМ открытой шинной архитектуры**  
Обмен данными через единую шину между процессором, памятью и устройствами ввода-вывода.  

---

#### **Задача: Алгоритм машины Тьюринга (из 4 в 5)**  

**Идея:**  
- Читаем число в 4СС.  
- Переводим в 5СС (деление с остатком).  

**Код:**  
```c
#include <stdio.h>

void toBase(int n, int base) {
    if (n == 0) return;
    toBase(n / base, base);
    printf("%d", n % base);
}

int main() {
    int num;
    scanf("%d", &num);
    toBase(num, 5);
    return 0;
}
```
**Сложность:** \( O(\log_B N) \).  

---
Спасибо за терпение! Сейчас подробно разберу блоки **с 18 по 28**.  

---

## **Блок 18**  

### **Целые типы чисел. Теория множеств**  
В языке C есть несколько типов для представления целых чисел:  
- `char` (обычно 1 байт)  
- `short` (обычно 2 байта)  
- `int` (обычно 4 байта)  
- `long` (обычно 4 или 8 байтов)  
- `long long` (обычно 8 байтов)  

Теория множеств описывает операции над элементами, например:  
- **Объединение**: `A ∪ B`  
- **Пересечение**: `A ∩ B`  
- **Разность**: `A - B`  
- **Дополнение**: `A'`  

---

### **Что такое ЭВМ? Схема работы ЭВМ**  
ЭВМ (электронно-вычислительная машина) — устройство для обработки информации.  

**Компоненты:**  
1. **Процессор (CPU)** — выполняет команды.  
2. **Память (RAM, HDD/SSD)** — хранит данные.  
3. **Устройства ввода/вывода** — взаимодействие с пользователем.  

Цикл работы: **ввод → обработка → вывод**.  

---

### **Задача: Подсчет слов во входном файле**  

**Идея:**  
- Читаем файл посимвольно.  
- Разделители: пробелы, табуляции, переносы строк.  
- Учитываем начало нового слова.  

**Код:**  
```c
#include <stdio.h>
#include <ctype.h>

int main() {
    FILE *file = fopen("input.txt", "r");
    if (!file) return 1;
    
    int count = 0, inWord = 0;
    char c;

    while ((c = fgetc(file)) != EOF) {
        if (isspace(c)) inWord = 0;
        else if (!inWord) { inWord = 1; count++; }
    }

    fclose(file);
    printf("Words: %d\n", count);
    return 0;
}
```
**Сложность**: \( O(N) \), где `N` — количество символов.  

---

## **Блок 19**  

### **Блочная структура программ**  
Программы в C строятся из **блоков**, которые ограничены `{}`.  
Пример:  
```c
int main() {
    {
        int x = 5;
    } // x уничтожен
}
```  

---

### **Понятие архитектуры**  
Архитектура компьютера — принципы построения аппаратного и программного обеспечения.  
Основные виды:  
- **Фон Неймана** — общая память для данных и команд.  
- **Гарвардская** — раздельные памяти для команд и данных.  

---

### **Задача: Проверить возрастание цифр в 16СС**  

**Идея:**  
- Читаем число как строку.  
- Сравниваем соседние символы.  

**Код:**  
```c
#include <stdio.h>
#include <string.h>

int main() {
    char hex[20];
    scanf("%s", hex);
    
    for (int i = 0; i < strlen(hex) - 1; i++)
        if (hex[i] >= hex[i + 1]) {
            printf("NO\n");
            return 0;
        }

    printf("YES\n");
    return 0;
}
```
**Сложность**: \( O(N) \).  

---

## **Блок 20**  

### **Обобщённая инструкция цикла**  
В C есть три основных цикла:  
- `while (условие) {}`  
- `do { } while (условие);`  
- `for (инициализация; условие; шаг) {}`  

Обобщенно цикл записывается так:  
```c
for (начало; проверка; шаг) { тело }  
```

---

### **Клавиатура**  
Клавиатура — устройство ввода информации. Включает:  
- Клавиши буквенные и цифровые.  
- Функциональные клавиши.  
- Мультимедийные клавиши.  

---

### **Задача: Вывести первые 999 чисел Леонардо**  

**Идея:**  
- Числа Леонардо: `L(n) = L(n-1) + L(n-2) + 1`  
- Используем массив.  

**Код:**  
```c
#include <stdio.h>

int main() {
    long long L[999] = {1, 1};
    for (int i = 2; i < 999; i++)
        L[i] = L[i-1] + L[i-2] + 1;

    for (int i = 0; i < 999; i++)
        printf("%lld ", L[i]);

    return 0;
}
```
**Сложность**: \( O(N) \).  

---

## **Блок 21**  

### **Обобщенная инструкция композиции**  
Композиция — объединение операторов, например:  
```c
{ int a = 5; a++; printf("%d", a); }
```
Вложенные `{}` определяют область видимости.  

---

### **Системная плата**  
Системная плата (материнская плата) соединяет все компоненты ПК:  
- **Процессор**  
- **Оперативная память**  
- **Накопители**  

---

### **Задача: Возведение в квадрат бинарной матрицы 8×8**  

**Идея:**  
- Булевая матрица `0` и `1`.  
- Умножаем по `XOR`.  

**Код:**  
```c
#include <stdio.h>

#define SIZE 8

void multiply(int A[SIZE][SIZE], int B[SIZE][SIZE]) {
    int res[SIZE][SIZE] = {0};
    for (int i = 0; i < SIZE; i++)
        for (int j = 0; j < SIZE; j++)
            for (int k = 0; k < SIZE; k++)
                res[i][j] ^= A[i][k] & B[k][j];

    for (int i = 0; i < SIZE; i++)
        for (int j = 0; j < SIZE; j++)
            A[i][j] = res[i][j];
}

int main() {
    int A[SIZE][SIZE] = { {1,0,1,0,1,0,1,0}, ... };
    multiply(A, A);
}
```
**Сложность**: \( O(N^3) \).  

---

## **Блок 22**  

### **Передача параметров по ссылке**  
В C передача по ссылке моделируется через указатели:  
```c
void func(int *a) { *a += 1; }
int main() {
    int x = 5;
    func(&x);
    printf("%d", x); // 6
}
```  

---

### **Пишущая машинка**  
Устройство для механической печати текста.  

---

### **Задача: Деление двоичных чисел в строках**  

**Идея:**  
- Читаем двоичные строки.  
- Переводим в `int`.  
- Делим, переводим обратно.  

**Код:**  
```c
#include <stdio.h>
#include <stdlib.h>

int binToDec(char *bin) {
    return strtol(bin, NULL, 2);
}

void decToBin(int num) {
    if (num == 0) return;
    decToBin(num / 2);
    printf("%d", num % 2);
}

int main() {
    char a[32], b[32];
    scanf("%s %s", a, b);
    
    int num1 = binToDec(a);
    int num2 = binToDec(b);
    
    if (num2 == 0) { printf("Error\n"); return 1; }

    decToBin(num1 / num2);
}
```
**Сложность**: \( O(\log N) \).  

---
### **Блок 23**  

#### **Обобщённая инструкция композиции**  
Обобщённая инструкция композиции в C — это объединение операторов `{ }`, обеспечивающее структурированное выполнение кода. Например:  
```c
{
    int x = 5;
    printf("%d\n", x);
}
```  
Блок `{}` позволяет ограничивать область видимости переменных.  

---

#### **Системная плата**  
Системная плата (материнская плата) — главный компонент компьютера, соединяющий процессор, память, накопители и периферийные устройства. Основные компоненты:  
- **Чипсет**  
- **Разъемы для ОЗУ**  
- **Слоты PCIe**  
- **BIOS/UEFI**  

---

#### **Задача: Возведение в квадрат бинарной матрицы 8×8**  

**Идея:**  
- Двоичная матрица содержит только `0` и `1`.  
- Перемножение матриц выполняется по правилам **логического И (`&`)** и **XOR (`^`)**.  

**Код:**  
```c
#include <stdio.h>

#define SIZE 8

void multiply(int A[SIZE][SIZE], int B[SIZE][SIZE]) {
    int res[SIZE][SIZE] = {0};
    for (int i = 0; i < SIZE; i++)
        for (int j = 0; j < SIZE; j++)
            for (int k = 0; k < SIZE; k++)
                res[i][j] ^= A[i][k] & B[k][j];

    for (int i = 0; i < SIZE; i++)
        for (int j = 0; j < SIZE; j++)
            A[i][j] = res[i][j];
}

int main() {
    int A[SIZE][SIZE] = { {1,0,1,0,1,0,1,0}, {0,1,0,1,0,1,0,1}, ... };
    multiply(A, A);
}
```
**Сложность**: \( O(N^3) \).  

---

### **Блок 24**  

#### **Описание процедур и функций**  
В C функции объявляются так:  
```c
тип_возвращаемого_значения имя_функции(параметры) {
    тело_функции;
    return значение;
}
```  
Пример:  
```c
int add(int a, int b) {
    return a + b;
}
```  

---

#### **Накопители на жестких магнитных дисках (HDD)**  
HDD — основной тип долговременной памяти, использующий магнитные пластины. Главные характеристики:  
- **Ёмкость**  
- **Скорость вращения (RPM)**  
- **Интерфейс (SATA, NVMe)**  

---

#### **Задача: Преобразование программы Тьюринга из пятёрок в четвёрки**  

**Идея:**  
- Машина Тьюринга работает с 5-ю элементами: `состояние, символ, новое состояние, новый символ, движение`.  
- Нужно преобразовать в 4-элементную запись, убирая `движение`, если оно фиксировано.  

**Код:**  
```c
#include <stdio.h>

int main() {
    char state[10], symbol[10], newState[10], newSymbol[10];
    int n;
    scanf("%d", &n);
    
    for (int i = 0; i < n; i++)
        scanf("%s %s %s %s", state, symbol, newState, newSymbol);
    
    for (int i = 0; i < n; i++)
        printf("%s %s %s %s\n", state, symbol, newState, newSymbol);

    return 0;
}
```
**Сложность**: \( O(N) \).  

---

### **Блок 25**  

#### **Рекурсия и итерации**  
Рекурсия — вызов функции самой себя.  
```c
int factorial(int n) {
    return (n == 0) ? 1 : n * factorial(n - 1);
}
```  
Итерация — использование циклов `for`, `while`:  
```c
int factorial(int n) {
    int res = 1;
    for (int i = 2; i <= n; i++) res *= i;
    return res;
}
```  

---

#### **Видеокарта**  
Видеокарта — устройство для обработки графики. Виды:  
- **Интегрированная**  
- **Дискретная**  

---

#### **Задача: Проверить лексикографический порядок булевых векторов**  

**Идея:**  
- Читаем два булевых вектора.  
- Сравниваем посимвольно.  

**Код:**  
```c
#include <stdio.h>
#include <string.h>

int main() {
    char a[10], b[10];
    scanf("%s %s", a, b);

    if (strcmp(a, b) < 0) printf("YES\n");
    else printf("NO\n");

    return 0;
}
```
**Сложность**: \( O(N) \).  

---

### **Блок 26**  

#### **Передача параметров по ссылке**  
В C передача по ссылке осуществляется через указатели:  
```c
void swap(int *a, int *b) {
    int temp = *a;
    *a = *b;
    *b = temp;
}
```  

---

#### **Пишущая машинка**  
Устройство для механической печати текста.  

---

#### **Задача: Деление двоичных чисел в строках**  

**Идея:**  
- Преобразуем двоичное число в `int`.  
- Делим.  
- Преобразуем обратно.  

**Код:**  
```c
#include <stdio.h>
#include <stdlib.h>

int binToDec(char *bin) {
    return strtol(bin, NULL, 2);
}

void decToBin(int num) {
    if (num == 0) return;
    decToBin(num / 2);
    printf("%d", num % 2);
}

int main() {
    char a[32], b[32];
    scanf("%s %s", a, b);
    
    int num1 = binToDec(a);
    int num2 = binToDec(b);
    
    if (num2 == 0) { printf("Error\n"); return 1; }

    decToBin(num1 / num2);
}
```
**Сложность**: \( O(\log N) \).  

---

### **Блок 27**  

#### **Передача параметров по значению**  
Передача параметров по значению означает, что в функцию передаётся **копия** аргумента:  
```c
void func(int x) { x = 10; }
```  
Оригинальное `x` не изменится.  

---

#### **RISC (Reduced Instruction Set Computer)**  
Архитектура процессоров с **простыми и быстрыми командами**.  

---

#### **Задача: Вывод числа по маске**  

**Идея:**  
- Читаем число.  
- Форматируем по маске (`printf`).  

**Код:**  
```c
#include <stdio.h>

int main() {
    int num;
    scanf("%d", &num);
    printf("Number: %08X\n", num);
    return 0;
}
```
**Сложность**: \( O(1) \).  

---

### **Блок 28**  

#### **Принцип реализации машины Фон Неймана**  
1. **Общая память** для данных и команд.  
2. **Цикл выборки-исполнения**.  
3. **Линейное выполнение команд**.  

---

#### **Запоминающее устройство**  
Запоминающее устройство (память) делится на:  
- **ОЗУ (RAM)** — оперативная память.  
- **ПЗУ (ROM)** — постоянная память.  
- **Кэш** — быстрая память внутри процессора.  

---

#### **Задача: Квадрат числа в натуральной СС**  

**Идея:**  
- Читаем число.  
- Возводим в квадрат.  
- Выводим в нужной системе.  

**Код:**  
```c
#include <stdio.h>

int main() {
    int num, base;
    scanf("%d %d", &num, &base);
    printf("%d\n", num * num);
    return 0;
}
```
**Сложность**: \( O(1) \).  
```
### **Блок 29**  

#### **Принцип реализации машины фон Неймана**  
Архитектура фон Неймана основана на следующих принципах:  
1. **Программа и данные хранятся в одной памяти**.  
2. **Используется единый канал передачи данных** (узкое место).  
3. **Программы исполняются последовательно**, за исключением переходов и ветвлений.  

Пример программы, которая выполняется по принципу фон Неймана:  
```c
#include <stdio.h>

int main() {
    int a = 5, b = 10;
    int sum = a + b;
    printf("Sum: %d\n", sum);
    return 0;
}
```
Здесь команды хранятся в памяти, читаются и выполняются последовательно.  

---

#### **Запоминающее устройство**  
Запоминающее устройство (ЗУ) — это компонент компьютера, отвечающий за хранение данных. Основные типы:  
- **ОЗУ (RAM)** — временное хранение данных.  
- **ПЗУ (ROM)** — постоянное хранение.  
- **Кэш-память** — быстрая память внутри процессора.  
- **Внешняя память** — HDD, SSD, флеш-накопители.  

---

#### **Задача: Квадрат числа в натуральной системе счисления**  

**Идея:**  
- Читаем число и систему счисления.  
- Возводим число в квадрат.  
- Выводим в указанной системе.  

**Код:**  
```c
#include <stdio.h>

void printInBase(int num, int base) {
    if (num == 0) return;
    printInBase(num / base, base);
    printf("%d", num % base);
}

int main() {
    int num, base;
    scanf("%d %d", &num, &base);
    printInBase(num * num, base);
    return 0;
}
```
**Сложность**: \( O(\log N) \).  

---

### **Блок 30**  

#### **Литерный тип**  
Литерный тип в C — это **символьный тип** (`char`). Символы заключаются в одинарные кавычки `'A'`.  
Пример:  
```c
char c = 'X';
printf("%c\n", c);
```
Строки — массив символов (`char[]`), заканчивающийся `\0`.  

---

#### **Принстонская архитектура**  
Принстонская (фон Неймана) архитектура использует **общую память** для данных и команд.  

Плюсы:  
✔ Простота реализации.  

Минусы:  
❌ Узкое место памяти (Bottleneck).  

В отличие от **Гарвардской архитектуры**, где память разделена на данные и инструкции.  

---

#### **Задача: Перевод вещественного числа в обыкновенную дробь**  

**Идея:**  
- Разделить число на целую и дробную часть.  
- Преобразовать дробную часть в числитель и знаменатель.  
- Вывести результат.  

**Код:**  
```c
#include <stdio.h>

void fraction(double num) {
    int intPart = (int)num;
    double frac = num - intPart;
    int denominator = 10000;  
    int numerator = frac * denominator;

    printf("%d + %d/%d\n", intPart, numerator, denominator);
}

int main() {
    double num;
    scanf("%lf", &num);
    fraction(num);
}
```
**Сложность**: \( O(1) \).  

---

### **Блок 31**  

#### **Операции присваивания (по имени)**  
В C операция `=` выполняет присваивание значений.  
```c
int a = 5;
a = a + 10;
```
Другие формы:  
```c
a += 10;  // Эквивалентно a = a + 10
a -= 5;   // Вычитание
a *= 2;   // Умножение
a /= 3;   // Деление
```
Присваивание может использоваться в выражениях:  
```c
int x, y;
x = (y = 5) + 3;  // y = 5, x = 8
```  

---

#### **Микрофон**  
Микрофон — устройство ввода звуковых данных. Основные характеристики:  
- **Чувствительность**  
- **Шумоподавление**  
- **Тип (динамический, конденсаторный)**  

---

#### **Задача: Дифференцирование в C**  

**Идея:**  
- Представляем многочлен в виде массива коэффициентов.  
- Для каждого члена понижаем степень, умножая коэффициент на степень.  

**Код:**  
```c
#include <stdio.h>

void differentiate(int coeffs[], int degree) {
    for (int i = 0; i < degree; i++)
        printf("%dx^%d ", coeffs[i] * (degree - i), degree - i - 1);
    printf("\n");
}

int main() {
    int coeffs[] = {3, -2, 5};  // 3x² - 2x + 5
    int degree = 2;
    differentiate(coeffs, degree);
}
```
**Сложность**: \( O(N) \).  

---

### **Блок 32**  

#### **Рекурсивный вызов процедуры**  
Рекурсивный вызов — это когда функция вызывает саму себя.  
Пример рекурсивного факториала:  
```c
int factorial(int n) {
    return (n == 0) ? 1 : n * factorial(n - 1);
}
```
Рекурсия полезна в деревьях, графах, алгоритмах `DFS`, `QuickSort`.  

---

#### **Архитектура процессора DSP**  
DSP (Digital Signal Processor) — процессоры для цифровой обработки сигналов.  

Характеристики:  
- **Многопоточность**  
- **Аппаратные ускорители для FFT, фильтрации**  
- **Малое энергопотребление**  

---

#### **Задача: Произведение многочленов**  

**Идея:**  
- Два массива коэффициентов представляют многочлены.  
- Перемножаем все коэффициенты, суммируем по степеням.  

**Код:**  
```c
#include <stdio.h>

void multiplyPolynomials(int A[], int B[], int n, int m) {
    int res[n + m - 1];
    for (int i = 0; i < n + m - 1; i++) res[i] = 0;

    for (int i = 0; i < n; i++)
        for (int j = 0; j < m; j++)
            res[i + j] += A[i] * B[j];

    for (int i = 0; i < n + m - 1; i++)
        printf("%dx^%d ", res[i], i);
    printf("\n");
}

int main() {
    int A[] = {1, 2, 3};  // 1 + 2x + 3x^2
    int B[] = {4, 5};     // 4 + 5x
    multiplyPolynomials(A, B, 3, 2);
}
```
**Сложность**: \( O(NM) \).  



## Процесс вызова рекурсии  
Рекурсия — это метод программирования, при котором функция вызывает саму себя. Используется для решения задач, которые могут быть разбиты на более простые подзадачи того же типа.  

### Этапы выполнения рекурсивного вызова:  
1. **Вызов функции** – создаётся новый стековый кадр, в котором сохраняются аргументы и локальные переменные.  
2. **Сохранение контекста** – предыдущие вызовы ждут завершения текущего вызова.  
3. **Рекурсивный переход** – выполняется новый вызов функции с изменёнными параметрами.  
4. **Базовый случай** – условие выхода, при котором рекурсия завершается.  
5. **Возврат результатов** – при достижении базового случая вычисления начинают возвращаться назад по стеку.  

### Особенности рекурсии:  
- Использует стек вызовов, что может привести к переполнению стека при глубокой рекурсии.  
- Может быть заменена циклом в некоторых случаях для оптимизации.  
- Время работы зависит от количества рекурсивных вызовов.  

## DSP (Цифровая обработка сигналов)  
Digital Signal Processing (DSP) — это обработка сигналов в цифровом виде для улучшения их качества, фильтрации, сжатия или других целей.  

### Основные этапы цифровой обработки сигналов:  
1. **Оцифровка** – преобразование аналогового сигнала в цифровой с помощью АЦП (аналого-цифрового преобразователя).  
2. **Предварительная обработка** – удаление шума, нормализация.  
3. **Фильтрация** – применение цифровых фильтров (КИХ, БИХ).  
4. **Частотный анализ** – применение БПФ (быстрого преобразования Фурье).  
5. **Обратное преобразование** – если требуется восстановление аналогового сигнала, используется ЦАП (цифро-аналоговый преобразователь).  

### Применение DSP:  
- Аудио и видео обработка  
- Радиосвязь  
- Системы управления  
- Обработка изображений  

Задача 1: Произведение многочленов
Идея решения:
Даны два многочлена в виде массивов коэффициентов.
Используем метод O(n²) для перемножения.
Результат записываем в массив.
c
```c
#include <stdio.h>
#include <string.h>

void multiply_polynomials(int A[], int B[], int n, int m, int result[]) {
    memset(result, 0, (n + m - 1) * sizeof(int));
    for (int i = 0; i < n; i++)
        for (int j = 0; j < m; j++)
            result[i + j] += A[i] * B[j];
}

int main() {
    int A[] = {1, 2, 3}; // 1 + 2x + 3x^2
    int B[] = {4, 5};    // 4 + 5x
    int result[4];

    multiply_polynomials(A, B, 3, 2, result);
    
    for (int i = 0; i < 4; i++)
        printf("%d ", result[i]);
    return 0;
}
```
Сложность: O(n * m)

## Блочная структура программ  
Блочная структура — принцип организации программы, при котором код разделяется на логические блоки, упрощающие чтение и сопровождение.  

### Основные принципы:  
1. **Модулярность** – код разбит на функции, классы, файлы.  
2. **Структурность** – использование последовательностей, ветвлений и циклов.  
3. **Инкапсуляция** – скрытие деталей реализации внутри модулей.  

### Преимущества:  
- Улучшение читаемости  
- Упрощение тестирования  
- Повторное использование кода  

## Понятие об архитектуре компьютера  
Архитектура компьютера — это структура и принципы работы вычислительной системы.  

### Основные компоненты:  
1. **Процессор (ЦП)** – выполняет команды.  
2. **Оперативная память (ОЗУ)** – хранит временные данные.  
3. **Система ввода-вывода** – взаимодействие с внешними устройствами.  
4. **Шина** – соединяет компоненты.  

### Виды архитектур:  
- **Фон Неймановская** – единая память для кода и данных.  
- **Гарвардская** – раздельная память для кода и данных.  
- **RISC и CISC** – разные подходы к проектированию команд процессора.  

---

## Задача: Проверить, что числа возрастают (16-ричная система)  
### Идея решения:  
1. Читаем строку из шестнадцатеричных чисел.  
2. Преобразуем их в десятичные.  
3. Проверяем, идут ли они в порядке возрастания.  

### Анализ алгоритма:  
- **Временная сложность** – O(n), так как требуется один проход по числам.  
- **Дополнительная память** – O(1), так как храним только предыдущее число.  

### Код:  
```c
#include <stdio.h>
#include <stdlib.h>

int is_increasing(const char *hex_numbers[], int size) {
    int prev = strtol(hex_numbers[0], NULL, 16);
    for (int i = 1; i < size; i++) {
        int curr = strtol(hex_numbers[i], NULL, 16);
        if (curr <= prev) return 0;
        prev = curr;
    }
    return 1;
}

int main() {
    const char *numbers[] = {"1A", "2F", "3B", "4C"};
    printf(is_increasing(numbers, 4) ? "YES\n" : "NO\n");
    return 0;
}

```  
Этот код проверяет, идет ли последовательность чисел по возрастанию.
---
